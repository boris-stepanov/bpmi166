{-# LANGUAGE NumericUnderscores #-}
{-# OPTIONS_GHC -fdefer-typed-holes #-}

module S3.Basic where

import Prelude (id, seq, Int, Num(..), Monoid(..), Ord(..))

{-
Порядок операций. Вызовы функций имеют приоритет, который как обычно можно корректировать скобками, и могут иметь левую или правую ассоциативность.
1. Префиксный вызов всегда имеет наивысший приоритет 10 и не ассоциативен, так как его арность неопределена. Это справедливо так же для инфиксных функций записаных через скобки: `(+) 2 3`
2. Инфиксный вызов через обратные кавычки имеет приоритет 9 и левоассоциативен: [] `mappend` []
3. Информацию об инфиксной функции можно посмотреть при помощи `:i (+)`
4. Можно самостоятельно настроить эти параметры для своих функций:
-}

(+-) :: Int -> Int -> Int
a +- b = a + b
infixl 7 +-     -- Левоассоциативная операция с приоритетом 7

{-
Можно выбрать `infix`, `infixl`, `infixr` для не-, лево- и правоассоциативной функции; приоритет должен быть от 0 до 9.

5. То же самое справедливо для функций на типах `:i (->)`
-}

------------------------------------------------ Продолжение

{-
Про порядок вычислений.
-}

someTerm = id (id (\z -> id z))

{-
 1. Полная beta-редукция - сворачиваем все редексы в любом порядке.
 2. Нормальный порядок - сворачиваем, начиная с левого внешнего редекса.
 3. Вызов-по-имени - сворачиваем левый внешний, но не внутри абстракции.
 4. Вызов-по-значению - сворачиваем левый внешний, если его аргумент сам значение (не абстракция).

Вызов-по-имени и даёт нам ленивость. В теории типов есть специальный тип `bottom` _|_ - тип не имеющий значений. Любой тип так же содержит bottom как подмножество - это ошибки, бесконечные циклы и т.д. Ленивость позволяет избегать _|_. В Хаскелле `0 * _|_ = 0`, в энергичных языках же `0 * _|_ = _|_`. Ленивость позволяет работать с бесконечными списками, комбинатором неподвижной точки и т.д.

Теорема: Пусть терм M имеет нормальную форму M'. Тогда M можно свести к M' в нормальном порядке.
-}

data Void

{-
Вызов-по-имени в Хаскелле приводит термы к WHNF - Weak Head Normal Form. По определению, это:
  1. Конструктор данных - Just (2+3), 1, True, (2+3):_|_
  2. Частично применённая функция - (+) 2, sqrt
  3. Лямбда абстракция - \x -> _|_
Функция `seq :: a -> b -> b` из base, сводит первый аргумент к WHNF и возвращает второй.
Сопоставление с образцом также редуцирует аргументы до тех пора, пока их не получится сравнить с образцами. Иногда это полезно отключить
-}

constOnTuple :: (a, b) -> Int
constOnTuple (a, b) = 0

lazyConstOnTuple :: (a, b) -> Int
lazyConstOnTuple ~(a, b) = 0

-- Сравните `constOnTuple undefined`

{-
 1. Ссылочная прозрачность (Referential Transparency) - замена любого выражения на его результат не меняет поведение программы.
 2. Функция - чистая, если для ссылочно прозрачных аргументов она является ссылочно прозрачной.
 3. Функция - нечистая, если она имеет side effects:

def random() -> int:
  result = random.randint(1, 10)      # <- side effect, результат функции random каждый раз разный, да ещё и состояние генератора могло поменяться.
  print("Hello there!")               # <- side effect, мы ждали int, а получили вывод в консоль
  return result

 4. Это даёт возможности мощной оптимизации - мемоизация локальных аргументов, кэширование, сборка мусора, непоследовательные вычисления и т.д.
 5. Все нечистые функции (работа с внешними данными, временем, конкуррентность) возможны только внутри функции main и её вызовов. По сути Хаскелл трактует внешний мир как ещё один аргумент программы.
-}

{-
Задачки: написать разные способы свёртки списка.
-}

-- Свёртка списка с хвоста. Проверить, что `foldr (+) 0 [0 .. 30_000_000]` сломается со stack overflow.
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr = _

-- Свёртка списка с начала. Проверить, что `foldl (+) 0 [0 .. 30_000_000]` сломается со stack overflow.
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl = _

-- Понять, почему ленивая свёртка слева так просто не работает и с помощью seq написать эффективную свёртку. Проверить, что `foldl' (+) 0 [0 .. 30_000_000]` посчитается за пару секунд.
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' = _

-- Умножение, ленивое по первому аргументу.
(?) :: Int -> Int -> Int
(?) _ 0 = 0
(?) a b = a * b

-- Зачем вообще нужны foldl, foldr? Сравните вызов `foldr(l,l') (?) 1 [1,2,undefined,0]`

{-
```
class Foldable t where
  foldMap :: Monoid m => (a -> m) -> t a -> m
  foldr :: (a -> b -> b) -> b -> t a -> b
  {-# MINIMAL foldMap | foldr #-}
```
-}

-- Фантомные переменные типа - это переменные, которые не участвуют в конструкторах данных:
data NotMaybe a b = NotNothing | NotJust a
-- b - фантомная переменная, все типы в семействе `NotMaybe a *` имеют одинаковые точки,
-- но компилятор всё равно будет проверять типы. Тип точки `NotNothing` не всегда равен типу точки `NotNothing`

-- Record syntax:

data Foo a = Foo { getA :: a, getInt :: Int } | Bar { getInt :: Int }

-- Тип эквивалентен типу `Foo a Int | Bar Int`, но у нас появились геттеры `getA`, `getInt`
-- :t getA :: Foo a -> a
-- И намного больше:

foo :: Foo a -> Int
foo Foo { getInt = x } = x
foo Bar { getInt = x } = x

setIntInFoo :: Foo a -> Int -> Foo a
setIntInFoo foo x = foo { getInt = x }

-- Также в pattern-matchinge при помощи @ можно добавлять биндинги к разным группам:

bar :: Foo a -> Foo a
bar x@(Foo y z) = if z > 0 then x { getInt = 5 } else x

-- Другой синтаксис для типов

type AnotherFoo a = Foo a
-- буквально синоним типа, при разборе программы заменяется на `Foo Int` везде.
-- Мы уже видели, что по определение `type String = [Char]`

data FooBoxed a = FooBoxed (Foo a)
{- Вообще-то создание типа при помощи data так же добавляет новый указатель.
Теперь, чтобы добраться до Int'а в глубине Foo, машине придётся сначала переходить по указателю FooBoxed, затем по Foo/Bar.
Есть расширения, позволяющие распаковать (unbox) внутренние данные, или можно воспользоваться newtype.
-}

newtype FooUnwrapped a = FooUnwrapped (Foo a)
{-
FooUnwrapped - новый тип и все особенности типов Хаскелла для него работают так же. Но после компиляции FooUnwrapped исчезает, оставляя только перегруженные функции.
newtype можно использовать не всегда - он должен иметь строго один конструктор данных с одним аргументом. То есть по сути только `<Mark> <OtherType>`.
На конструктор типа ограничений нет.
-}

-- Вопрос: почему в базовой библиотеке Хаскелля нет определения `instance Semigroup Int where...`?
-- Подсказка: попробуйте его определить самостоятельно.

{-
Ad-hoc и параметрический полиморфизм.
Ad-hoc полиморфизм - различное поведение функции для различных аргументов. В императивных языках достигается перегрузкой функций.
В Хаскелле - type class'ами. Фактически, мы пишем для разных типов разный код и машина должна во время вызова приводить тип и выбирать нужную реализацию.

Параметрический полиморфизм - когда функции работают с данными обобщённо, не вникая в конкретную структуру.
```
filter :: (a -> Bool) -> [a] -> [a]
elem :: (Foldable t, Eq a) => a -> t a -> Bool
```
-}

{-
Задачки
Написать функции, используя метод `foldMap` класса `Foldable` и newtype'ы Sum и Prod, которые отвечают на вопрос из строки 154
-}

sum :: Num a => [a] -> a
sum = _
prod :: Num a => [a] -> a
prod = _
