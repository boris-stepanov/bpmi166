{-# LANGUAGE NumericUnderscores #-}
{-# OPTIONS_GHC -fdefer-typed-holes #-}

module S3.Basic where

import Prelude (id, seq, Int, Num(..))

{-
Порядок операций. Вызовы функций имеют приоритет, который как обычно можно корректировать скобками, и могут иметь левую или правую ассоциативность.
1. Префиксный вызов всегда имеет наивысший приоритет 10 и не ассоциативен, так как его арность неопределена. Это справедливо так же для инфиксных функций записаных через скобки: `(+) 2 3`
2. Инфиксный вызов через обратные кавычки имеет приоритет 9 и левоассоциативен: [] `mappend` []
3. Информацию об инфиксной функции можно посмотреть при помощи `:i (+)`
4. Можно самостоятельно настроить эти параметры для своих функций:
-}

(+-) :: Int -> Int -> Int
a +- b = a + b
infixl 7 +-     -- Левоассоциативная операция с приоритетом 7

{-
Можно выбрать `infix`, `infixl`, `infixr` для не-, лево- и правоассоциативной функции; приоритет должен быть от 0 до 9.

5. То же самое справедливо для функций на типах `:i (->)`
-}

{-
Про порядок вычислений.
-}

someTerm = id (id (\z -> id z))

{-
 1. Полная beta-редукция - сворачиваем все редексы в любом порядке.
 2. Нормальный порядок - сворачиваем, начиная с левого внешнего редекса.
 3. Вызов-по-имени - сворачиваем левый внешний, но не внутри абстракции.
 4. Вызов-по-значению - сворачиваем левый внешний, если его аргумент сам значение (не абстракция).

Вызов-по-имени и даёт нам ленивость. В теории типов есть специальный тип `bottom` _|_ - тип не имеющий значений. Любой тип так же содержит bottom как подмножество - это ошибки, бесконечные циклы и т.д. Ленивость позволяет избегать _|_. В Хаскелле `0 * _|_ = 0`, в энергичных языках же `0 * _|_ = _|_`. Ленивость позволяет работать с бесконечными списками, комбинатором неподвижной точки и т.д.

Теорема: Пусть терм M имеет нормальную форму M'. Тогда M можно свести к M' в нормальном порядке.
-}

data Void

{-
Вызов-по-имени в Хаскелле приводит термы к WHNF - Weak Head Normal Form. По определению, это:
  1. Конструктор данных - Just (2+3), 1, True, (2+3):_|_
  2. Частично применённая функция - (+) 2, sqrt
  3. Лямбда абстракция - \x -> _|_
Функция `seq :: a -> b -> b` из base, сводит первый аргумент к WHNF и возвращает второй.
-}

{-
 1. Ссылочная прозрачность (Referential Transparency) - замена любого выражения на его результат не меняет поведение программы.
 2. Функция - чистая, если для ссылочно прозрачных аргументов она является ссылочно прозрачной.
 3. Функция - нечистая, если она имеет side effects:

def random() -> int:
  result = random.randint(1, 10)      # <- side effect, результат функции random каждый раз разный, да ещё и состояние генератора могло поменяться.
  print("Hello there!")               # <- side effect, мы ждали int, а получили вывод в консоль
  return result

 4. Это даёт возможности мощной оптимизации - мемоизация локальных аргументов, кэширование, сборка мусора, непоследовательные вычисления и т.д.
 5. Все нечистые функции (работа с внешними данными, временем, конкуррентность) возможны только внутри функции main и её вызовов. По сути Хаскелл трактует внешний мир как ещё один аргумент программы.
-}

{-
Задачки: написать разные способы свёртки списка.
-}

-- Свёртка списка с хвоста. Проверить, что `foldr (+) 0 [0 .. 30_000_000]` сломается со stack overflow.
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr = _

-- Свёртка списка с начала. Проверить, что `foldl (+) 0 [0 .. 30_000_000]` сломается со stack overflow.
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl = _

-- Понять, почему ленивая свёртка слева так просто не работает и с помощью seq написать эффективную свёртку. Проверить, что `foldl' (+) 0 [0 .. 30_000_000]` посчитается за пару секунд.
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' = _

-- Зачем вообще нужны foldl, foldr? Сравните вызов `fold (?) 1 [1,2,undefined,0]`

-- Умножение, ленивое по первому аргументу.
(?) :: Int -> Int -> Int
(?) _ 0 = 0
(?) a b = a * b

